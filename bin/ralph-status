#!/bin/bash

# ralph-status: Show task completion summary from PRD.md (markdown format)

RALPH_DIR=".ralph"
PRD_FILE="$RALPH_DIR/PRD.md"
PROGRESS_FILE="$RALPH_DIR/PROGRESS.md"
TECH_PLAN_FILE="$RALPH_DIR/TECH_PLAN.md"
ACTIVE_FILE="$RALPH_DIR/ralph-active.json"

echo "Ralph Status"
echo "============"
echo ""

if [ ! -d "$RALPH_DIR" ]; then
    echo "No .ralph directory found."
    echo "Run 'ralph-init' to initialize this project."
    exit 1
fi

if [ ! -f "$PRD_FILE" ]; then
    echo "No PRD.md found at $PRD_FILE"
    echo "Run 'ralph-plan' to create tasks."
    exit 1
fi

# Check if file is empty or just has template header
content=$(cat "$PRD_FILE")
if [ -z "$content" ] || [ "$content" = "# PRD" ]; then
    echo "PRD is empty. Run 'ralph-plan' to create tasks."
    exit 0
fi

# Parse markdown PRD and show status
python3 << 'PYEOF'
import re
import os
import json

# ANSI color codes
YELLOW = "\033[33m"
RESET = "\033[0m"

ralph_dir = ".ralph"
prd_file = os.path.join(ralph_dir, "PRD.md")
progress_file = os.path.join(ralph_dir, "PROGRESS.md")
tech_plan_file = os.path.join(ralph_dir, "TECH_PLAN.md")
active_file = os.path.join(ralph_dir, "ralph-active.json")

try:
    with open(prd_file, "r") as f:
        content = f.read()
except Exception as e:
    print(f"Error reading PRD: {e}")
    exit(1)

# Extract feature name from title
title_match = re.search(r'^#\s+PRD:\s*(.+)$', content, re.MULTILINE)
feature_name = title_match.group(1).strip() if title_match else "Unknown Feature"
print(f"Feature: {feature_name}")
print("")

# Check for tech plan
has_tech_plan = os.path.exists(tech_plan_file)
if has_tech_plan:
    # Check if it has meaningful content
    try:
        with open(tech_plan_file, "r") as f:
            tech_content = f.read().strip()
        if tech_content and len(tech_content) > 50:
            # Extract tech plan title if present
            tech_title_match = re.search(r'^#\s+Technical Plan:\s*(.+)$', tech_content, re.MULTILINE)
            if tech_title_match:
                print(f"Tech Plan: âœ… Ready ({tech_title_match.group(1).strip()})")
            else:
                print("Tech Plan: âœ… Ready")
        else:
            has_tech_plan = False
    except Exception:
        has_tech_plan = False

if not has_tech_plan:
    print(f"Tech Plan: {YELLOW}âš  Not written (run 'ralph-tech-plan' to create){RESET}")

print("")

# Load active tasks
active_tasks = []
try:
    with open(active_file, "r") as f:
        active_tasks = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    active_tasks = []

# Load progress content
progress_content = ""
try:
    with open(progress_file, "r") as f:
        progress_content = f.read()
except FileNotFoundError:
    pass

# Find tasks by section headers - support both formats:
# Format 1: ### P0-1: Task Name
# Format 2: ### Task 1: Task Name
task_headers = re.findall(r'^###\s+(P\d+-\d+):\s*(.+?)$', content, re.MULTILINE)
task_headers_alt = re.findall(r'^###\s+(Task\s+\d+):\s*(.+?)$', content, re.MULTILINE)

# Build task info
all_tasks = []

# Process P0-1 format
priorities = {'P0': [], 'P1': [], 'P2': [], 'P3': []}
for task_id, task_name in task_headers:
    priority = task_id.split('-')[0]
    task_section = re.search(rf'###\s+{re.escape(task_id)}:.*?(?=\n###|\n---|\Z)', content, re.DOTALL)
    is_complete = False
    is_blocked = False
    if task_section:
        section_text = task_section.group(0)
        is_complete = 'âœ…' in section_text[:100] or '[DONE]' in section_text[:100] or '~~' in task_name
        is_blocked = 'ðŸš«' in section_text[:100] or 'BLOCKED' in section_text[:100]
    if priority in priorities:
        priorities[priority].append((task_id, task_name.strip(), is_complete, is_blocked))
    all_tasks.append((task_id, task_name.strip(), is_complete, is_blocked))

# Process Task N format
for task_id, task_name in task_headers_alt:
    # Check if task is marked complete (has âœ… or [DONE] in header line)
    is_complete = 'âœ…' in task_name or '[DONE]' in task_name
    is_blocked = 'ðŸš«' in task_name or 'BLOCKED' in task_name
    # Clean up the task name
    clean_name = task_name.replace('âœ…', '').replace('[DONE]', '').replace('ðŸš«', '').replace('BLOCKED', '').strip()
    all_tasks.append((task_id, clean_name, is_complete, is_blocked))

# Calculate totals from all_tasks (works for both formats)
total_tasks = len(all_tasks)
completed_tasks = sum(1 for _, _, done, _ in all_tasks if done)
blocked_tasks = sum(1 for _, _, _, blocked in all_tasks if blocked)
pending_tasks = total_tasks - completed_tasks - blocked_tasks
in_progress_count = len(active_tasks)

# Determine which task is in progress
# If there are active tasks, the first non-complete, non-blocked task is in progress
in_progress_task_id = None
if active_tasks:
    for task_id, task_name, is_complete, is_blocked in all_tasks:
        if not is_complete and not is_blocked:
            in_progress_task_id = task_id
            break

# Determine status intelligently
# Priority: active tasks â†’ all complete â†’ last from PROGRESS.md â†’ default
if active_tasks:
    status = "ðŸŸ¡ In Progress"
elif total_tasks > 0 and completed_tasks == total_tasks:
    status = "ðŸŸ¢ Done"
else:
    # Find LAST status match in progress file (not first)
    status_matches = re.findall(r'^##\s+Status:\s*(.+)$', progress_content, re.MULTILINE)
    if status_matches:
        last_status = status_matches[-1].strip()
        # Check if blocked
        if 'BLOCKED' in last_status:
            status = last_status  # Keep the full blocked status with reason
        else:
            status = last_status
    else:
        status = "ðŸ”´ Not Started"

print(f"Status: {status}")
print("")

# Show task summary
if total_tasks > 0:
    parts = []
    if completed_tasks > 0:
        parts.append(f"{completed_tasks} done")
    if in_progress_count > 0:
        parts.append(f"{in_progress_count} in progress")
    if blocked_tasks > 0:
        parts.append(f"{blocked_tasks} blocked")
    if pending_tasks - in_progress_count > 0:
        parts.append(f"{pending_tasks - in_progress_count} pending")

    print(f"Tasks: {', '.join(parts)} (of {total_tasks})")
    print("")

    # Show task list with status icons
    for task_id, task_name, is_complete, is_blocked in all_tasks:
        # Check if this task is currently in progress
        task_in_progress = (task_id == in_progress_task_id)

        if is_complete:
            icon = "âœ…"
            line = f"  {icon} {task_id}: "
        elif is_blocked:
            icon = "ðŸš«"
            line = f"  {icon} {task_id}: "
        elif task_in_progress:
            icon = "ðŸ”„"
            line = f"  {YELLOW}{icon} {task_id}: "
        else:
            icon = "â¬œ"
            line = f"  {icon} {task_id}: "

        # Truncate long names
        display_name = task_name[:55] + "..." if len(task_name) > 55 else task_name
        # Remove status markers from display name if already in icon
        display_name = display_name.replace(" âœ…", "").replace("âœ… ", "").replace("âœ…", "")
        display_name = display_name.replace(" ðŸš«", "").replace("ðŸš« ", "").replace("ðŸš«", "")
        display_name = display_name.replace(" BLOCKED", "").replace("BLOCKED ", "").replace("BLOCKED", "")
        
        if task_in_progress:
            print(f"{line}{display_name}{RESET}")
        else:
            print(f"{line}{display_name}")
    print("")

# Show in-progress task details
if active_tasks:
    print(f"{YELLOW}In Progress: {len(active_tasks)} task(s){RESET}")
    for task in active_tasks:
        desc = task.get('description', '').strip()
        # If description is empty, use the detected in-progress task
        if not desc and in_progress_task_id:
            for tid, tname, _, _ in all_tasks:
                if tid == in_progress_task_id:
                    desc = f"{tid}: {tname}"
                    break
        if not desc:
            desc = "Unknown task"
        # Truncate if needed
        desc = desc[:60] + "..." if len(desc) > 60 else desc
        started = task.get('started', '?')
        sandbox = task.get('sandbox', '?')
        pid = task.get('pid', '?')
        print(f"  {YELLOW}â€¢ {desc}{RESET}")
        print(f"    Started: {started} | PID: {pid} | Sandbox: {sandbox}")
    print("")

# Show active blockers from PROGRESS.md
if progress_content and blocked_tasks > 0:
    blockers_section = re.search(r'##\s+Blockers.*?\n(.*?)(?=\n##|\Z)', progress_content, re.DOTALL)
    if blockers_section:
        blockers_text = blockers_section.group(1).strip()
        if blockers_text:
            print(f"Active Blockers:")
            # Parse blocker entries (bullet points)
            blocker_lines = [
                line.strip()
                for line in blockers_text.split('\n')
                if line.strip() and (line.strip().startswith('-') or line.strip().startswith('â€¢'))
            ]
            for line in blocker_lines[:5]:  # Show up to 5 blockers
                print(f"  {line}")
            print("")

# Show milestones from progress file
try:
    if progress_content:
        milestones_section = re.search(r'##\s+Milestones.*?\n(.*?)(?=\n##|\Z)', progress_content, re.DOTALL)
        if milestones_section:
            milestones_text = milestones_section.group(1)
            milestone_headers = re.findall(r'###\s+([â¬œâœ…])\s+(M\d+:.*?)$', milestones_text, re.MULTILINE)
            if milestone_headers:
                print("Milestones:")
                for status_icon, name in milestone_headers:
                    print(f"  {status_icon} {name.strip()}")
                print("")
except Exception:
    pass

# Recent Activity - structured output
print("Recent Activity:")
print("---")

# Show last completed task
completed_list = [
    (task_id, task_name)
    for task_id, task_name, done, _ in all_tasks
    if done
]
if completed_list:
    last_id, last_name = completed_list[-1]
    last_name = last_name.replace(" âœ…", "").replace("âœ… ", "").replace("âœ…", "").strip()
    print(f"Last completed: {last_id} - {last_name[:50]}")

# Show what's being worked on
if active_tasks:
    for task in active_tasks:
        desc = task.get('description', '').strip()
        # If description is empty, use the detected in-progress task
        if not desc and in_progress_task_id:
            for tid, tname, _, _ in all_tasks:
                if tid == in_progress_task_id:
                    desc = f"{tid}: {tname}"
                    break
        if desc:
            print(f"Working on: {YELLOW}{desc}{RESET}")

# Show recent decisions from progress file (last 3)
if progress_content:
    decisions_section = re.search(r'##\s+Decisions Log.*?\n(.*?)(?=\n##|\Z)', progress_content, re.DOTALL)
    if decisions_section:
        decisions_text = decisions_section.group(1)
        # Find decision entries (usually bullet points with dates or descriptions)
        decision_lines = [
            line.strip()
            for line in decisions_text.split('\n')
            if line.strip() and line.strip().startswith('-')
        ]
        if decision_lines:
            print("")
            print("Recent decisions:")
            for line in decision_lines[-3:]:
                print(f"  {line}")
PYEOF
