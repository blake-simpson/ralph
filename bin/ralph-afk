#!/bin/bash
set -e

# ralph-afk: Run multiple task iterations in Docker sandbox
# Usage: ralph-afk <iterations> [--loud]

# Parse arguments
ITERATIONS=""
LOUD=false

for arg in "$@"; do
    case $arg in
        --loud)
            LOUD=true
            ;;
        *)
            if [ -z "$ITERATIONS" ] && [[ "$arg" =~ ^[0-9]+$ ]]; then
                ITERATIONS="$arg"
            fi
            ;;
    esac
done

if [ -z "$ITERATIONS" ]; then
    echo "Usage: ralph-afk <iterations> [--loud]"
    echo ""
    echo "Runs Claude in Docker sandbox for the specified number of iterations."
    echo "Each iteration implements one task from the PRD."
    echo ""
    echo "Options:"
    echo "  --loud    Enable voice announcements"
    exit 1
fi

RALPH_DIR=".ralph"
PRD_FILE="$RALPH_DIR/PRD.md"
PROGRESS_FILE="$RALPH_DIR/PROGRESS.md"
TECH_PLAN_FILE="$RALPH_DIR/TECH_PLAN.md"
ACTIVE_FILE="$RALPH_DIR/ralph-active.json"
CONFIG_FILE="$HOME/.ralph/config"

# Get the directory where this script lives
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared prompt
source "$SCRIPT_DIR/ralph-prompt"

# Check if .ralph directory exists
if [ ! -d "$RALPH_DIR" ]; then
    echo "Error: No .ralph directory found."
    echo ""
    echo "Please run 'ralph-init' first to initialize this project."
    exit 1
fi

# Load config if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Export FIGMA_TOKEN if set (docker sandbox inherits environment)
if [ -n "$FIGMA_TOKEN" ]; then
    export FIGMA_TOKEN
fi

WORKSPACE="$(pwd)"
SANDBOX_NAME="claude-$(basename "$WORKSPACE")"

# Initialize active file if needed
if [ ! -f "$ACTIVE_FILE" ]; then
    echo "[]" > "$ACTIVE_FILE"
fi

# Function: Add task to active list
add_active_task() {
    local description="$1"
    local entry=$(python3 -c "
import json, sys
from datetime import datetime
entry = {
    'description': sys.argv[1],
    'started': datetime.now().isoformat(),
    'pid': $$,
    'sandbox': '$SANDBOX_NAME'
}
print(json.dumps(entry))
" "$description")

    python3 -c "
import json
with open('$ACTIVE_FILE', 'r') as f:
    active = json.load(f)
active.append($entry)
with open('$ACTIVE_FILE', 'w') as f:
    json.dump(active, f, indent=2)
"
}

# Function: Remove task from active list
remove_active_task() {
    python3 -c "
import json
with open('$ACTIVE_FILE', 'r') as f:
    active = json.load(f)
active = [t for t in active if t.get('pid') != $$]
with open('$ACTIVE_FILE', 'w') as f:
    json.dump(active, f, indent=2)
"
}

# Function: Get next pending task description from markdown PRD
get_next_task() {
    python3 -c "
import re
with open('$PRD_FILE', 'r') as f:
    content = f.read()

# Find task headers (### P0-1:, ### P1-1:, etc.) - prioritized by P0 > P1 > P2 > P3
task_headers = re.findall(r'^###\s+(P\d+-\d+):\s*(.+?)$', content, re.MULTILINE)

# Sort by priority (P0 first)
for task_id, task_name in sorted(task_headers, key=lambda x: x[0]):
    # Check if task is marked complete (has âœ… or [DONE]) or blocked (has ðŸš« or BLOCKED)
    task_section = re.search(rf'###\s+{re.escape(task_id)}:.*?(?=\n###|\n---|\Z)', content, re.DOTALL)
    if task_section:
        section_text = task_section.group(0)
        # Skip completed tasks
        if 'âœ…' in section_text[:100] or '[DONE]' in section_text[:100] or '~~' in task_name:
            continue
        # Skip blocked tasks
        if 'ðŸš«' in section_text[:100] or 'BLOCKED' in section_text[:100]:
            continue
        print(f'{task_id}: {task_name.strip()[:50]}')
        break
"
}

# Function: Check if all tasks are complete
all_tasks_complete() {
    python3 -c "
import re
with open('$PRD_FILE', 'r') as f:
    content = f.read()

task_headers = re.findall(r'^###\s+(P\d+-\d+):\s*(.+?)$', content, re.MULTILINE)

if not task_headers:
    exit(1)  # No tasks found

for task_id, task_name in task_headers:
    task_section = re.search(rf'###\s+{re.escape(task_id)}:.*?(?=\n###|\n---|\Z)', content, re.DOTALL)
    if task_section:
        section_text = task_section.group(0)
        is_complete = 'âœ…' in section_text[:100] or '[DONE]' in section_text[:100] or '~~' in task_name
        is_blocked = 'ðŸš«' in section_text[:100] or 'BLOCKED' in section_text[:100]
        if not is_complete and not is_blocked:
            exit(1)  # Found incomplete task

exit(0)  # All tasks complete or blocked
"
}

# Function: Update status to In Progress if currently Not Started
update_status_to_in_progress() {
    if [ -f "$PROGRESS_FILE" ]; then
        if grep -q "^## Status: ðŸ”´ Not Started" "$PROGRESS_FILE"; then
            sed -i '' 's/^## Status: ðŸ”´ Not Started/## Status: ðŸŸ¡ In Progress/' "$PROGRESS_FILE"
            echo "Status updated to ðŸŸ¡ In Progress"
        fi
    fi
}

# Clean up on exit (remove active task)
trap remove_active_task EXIT

# Check sandbox exists
if ! docker sandbox ls 2>/dev/null | grep -q "^$SANDBOX_NAME "; then
    echo "Error: Sandbox '$SANDBOX_NAME' not found."
    echo "Run 'ralph-init' first to set up the Docker sandbox."
    exit 1
fi

# Update status before starting work
update_status_to_in_progress

# Build file list for prompt
FILES_TO_READ="$PRD_FILE $PROGRESS_FILE"
if [ -f "$TECH_PLAN_FILE" ]; then
    FILES_TO_READ="$FILES_TO_READ $TECH_PLAN_FILE"
fi

for ((i=1; i<=$ITERATIONS; i++)); do
    echo "=== Iteration $i of $ITERATIONS ==="
    if [ "$LOUD" = true ]; then
        say --voice Zarvox "Iteration $i of $ITERATIONS" 2>/dev/null || true
    fi

    # Check if all tasks are complete before starting
    if all_tasks_complete; then
        echo "All tasks complete!"
        if [ "$LOUD" = true ]; then
            say --voice Zarvox "All tasks complete" 2>/dev/null || true
        fi
        exit 0
    fi

    # Track the current task as active
    CURRENT_TASK=$(get_next_task)
    if [ -z "$CURRENT_TASK" ]; then
        echo "No more tasks to work on."
        exit 0
    fi
    
    add_active_task "$CURRENT_TASK"
    echo "Working on: $CURRENT_TASK"

    # Run Claude in sandbox - it will update files directly
    docker sandbox run \
        "$SANDBOX_NAME" -- --permission-mode acceptEdits -p "$FILES_TO_READ
$RALPH_TASK_PROMPT"

    # Remove the active task after Claude completes
    remove_active_task

    # Check if blocked (look for BLOCKED status in progress file)
    if grep -q "^## Status: ðŸ”´ BLOCKED" "$PROGRESS_FILE" 2>/dev/null; then
        echo ""
        echo "ðŸš« Task blocked. Check .ralph/PROGRESS.md for details."
        if [ "$LOUD" = true ]; then
            say --voice Zarvox "Task blocked" 2>/dev/null || true
        fi
        exit 2
    fi

    echo ""
done

echo ""
echo "Completed $ITERATIONS iterations."
if [ "$LOUD" = true ]; then
    say --voice Zarvox "All iterations complete" 2>/dev/null || true
fi
